// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::conv::{ConvError, parse_float, parse_int, parse_uint}
use std::jule::ast::{
	Expr,
	LitExpr,
	IdentExpr,
	VariadicExpr,
	UnaryExpr,
	UnsafeExpr,
	SliceExpr,
	ExprData,
	FnDecl,
	BinopExpr,
	BraceLit,
	TupleExpr,
	SubIdentExpr,
	IndexingExpr,
	NsSelectionExpr,
	TypeDecl,
	FnCallExpr,
	SlicingExpr,
	CastExpr,
	StructLit,
	KeyValPair,
}
use std::jule::build::{errorf}
use std::jule::constant::{
	Const,
	new_bool,
	new_f64,
	new_nil,
	new_str,
	new_i64,
	new_u64,
}
use std::jule::constant::lit::{to_str, to_raw_str, to_rune, is_byte_lit}
use std::jule::lex::{
	self,
	Token,
	TokenKind,
	is_float,
	is_str,
	is_bool,
	is_rune,
	is_byte,
	is_raw_str,
}
use std::jule::types::{
	SYS_INT,
	SYS_UINT,
	MAX_I8,
	MAX_I16,
	MAX_I32,
	MAX_I64,
	MAX_U8,
	MAX_U16,
	MAX_U32,
	MAX_U64,
	MAX_F32,
	MAX_F64,
	MIN_I8,
	MIN_I16,
	MIN_I32,
	MIN_I64,
	MIN_F32,
	MIN_F64,
	max_of,
	min_of,
	is_num,
	is_int,
	is_sig_int,
	is_unsig_int,
	is_float,
	int_from_bits,
	uint_from_bits,
	float_from_bits,
	bitsize_of_int,
	bitsize_of_uint,
	bitsize_of_float,
	is_greater,
}

fn find_builtins_import(ident: str, imp: &ImportInfo): any {
	ret find_package_builtin_def(imp.link_path, ident)
}

fn find_builtins_sema(ident: str, s: &Sema): any {
	for _, imp in s.file.imports {
		if imp.import_all || imp.exist_ident(ident) {
			let mut def = find_builtins_import(ident, imp)
			if def != nil {
				ret def
			}
		}
	}
	ret nil
}

fn is_ok_for_shifting(mut d: &Data): bool {
	let prim = d.kind.prim()
	if !real(prim) || !is_int(prim.to_str()) {
		ret false
	}

	if !d.is_const() {
		ret true
	}

	match {
	| d.constant.is_i64(): ret d.constant.read_i64() >= 0
	| d.constant.is_u64(): ret true
	|:                     ret false
	}
}

fn is_instanced_struct(s: &StructIns): bool {
	ret s.decl.generics.len == s.generics.len
}

fn normalize_bitsize(mut d: &Data) {
	if !d.is_const() {
		ret
	}

	let mut kind = ""
	match {
	| d.constant.is_f64():
		let x = d.constant.read_f64()
		kind = float_from_bits(bitsize_of_float(x))

	| d.constant.is_i64():
		let x = d.constant.read_i64()
		kind = int_from_bits(bitsize_of_int(x))

	| d.constant.is_u64():
		let x = d.constant.read_u64()
		kind = uint_from_bits(bitsize_of_uint(x))

	|:
		ret
	}

	// Save enum.
	if real(d.kind.enm()) {
		ret
	}

	d.kind.kind = build_prim_type(kind)
}

fn normalize_type(mut d: &Data) {
	match {
	| int_assignable((str)(PrimKind.Int), d):
		d.kind.kind = build_prim_type((str)(PrimKind.Int))
		d.constant.set_i64(i64(d.constant.as_f64()))

	| int_assignable((str)(PrimKind.Uint), d):
		d.kind.kind = build_prim_type((str)(PrimKind.Uint))
		d.constant.set_u64(u64(d.constant.as_f64()))
	}
}

fn apply_cast_kind(mut d: &Data) {
	if !real(d.cast_kind) {
		ret
	}

	d.model = &CastingExprModel{
		expr:      d.model,
		kind:      d.cast_kind,
		expr_kind: d.kind,
	}
	d.kind = d.cast_kind
	drop(d.cast_kind) // Ignore, because model added.
}

fn build_void_data(): &Data {
	ret &Data{
		mutable:  false,
		lvalue:   false,
		decl:     false,
		kind: &TypeKind{
			kind: build_prim_type("void"),
		},
	}
}

fn kind_by_bitsize(expr: any): str {
	match type expr {
	| f64:
		let x = (f64)(expr)
		ret float_from_bits(bitsize_of_float(x))

	| i64:
		let x = (i64)(expr)
		ret int_from_bits(bitsize_of_int(x))

	| u64:
		let x = (u64)(expr)
		ret uint_from_bits(bitsize_of_uint(x))

	|:
		ret ""
	}
}

fn check_data_for_integer_indexing(mut d: &Data): (err_key: str) {
	if !real(d) {
		ret ""
	}

	let mut kind = d.kind
	if real(kind.ref()) {
		kind = kind.ref().elem
	}

	match {
	| !real(kind.prim()):
		ret "invalid_expr"

	| !is_int(kind.prim().to_str()):
		ret "invalid_expr"

	| d.is_const() && d.constant.as_i64() < 0:
		ret "overflow_limits"

	|:
		d.cast_kind = &TypeKind{kind: build_prim_type((str)(PrimKind.Int))}
		apply_cast_kind(d)
		ret ""
	}
}

// Value data.
pub struct Data {
	pub kind:       &TypeKind
	pub cast_kind:  &TypeKind // This expression should be cast to this kind.
	pub mutable:    bool
	pub lvalue:     bool
	pub variadiced: bool
	pub is_rune:    bool
	pub model:      ExprModel

	// True if kind is declaration such as:
	//  - &Enum
	//  - &Struct
	//  - int type
	//  - bool type
	pub decl: bool

	// Constant expression data.
	pub constant: &Const
}

impl Data {
	// Reports whether Data is nil literal.
	pub fn is_nil(self): bool { ret self.kind.is_nil() }

	// Reports whether Data is void.
	pub fn is_void(self): bool { ret self.kind.is_void() }

	// Reports whether Data is constant expression.
	pub fn is_const(self): bool { ret real(self.constant) }
}

// Value.
pub struct Value {
	pub expr: &Expr
	pub data: &Data
}

// Evaluator.
struct Eval {
	s:        &Sema // Used for error logging.
	lookup:   Lookup
	prefix:   &TypeKind
	unsafety: bool
	owner:    &Var
}

impl Eval {
	fn push_err(mut self, token: Token, key: str, args: ...any) {
		self.s.errors = append(self.s.errors, compiler_err(token, key, args...))
	}

	// Reports whether evaluation in unsafe scope.
	fn is_unsafe(self): bool { ret self.unsafety }

	// Reports whether evaluated expression is in global scope.
	fn is_global(self): bool {
		match type self.lookup {
		| &Sema: ret true
		|:       ret false
		}
	}

	fn lit_nil(self): &Data {
		// Return new Data with nil kind.
		// Nil kind represents "nil" literal.

		let mut constant = new_nil()
		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: constant,
			decl:     false,
			kind:     &TypeKind{kind: nil},
			model:    constant,
		}
	}

	fn lit_str(self, lt: &LitExpr): &Data {
		let mut s = lt.value[1 : lt.value.len-1] // Remove quotes.
		if is_raw_str(lt.value) {
			s = to_raw_str(([]byte)(s))
		} else {
			s = to_str(([]byte)(s))
		}
		let mut constant = new_str(s)

		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: constant,
			decl:     false,
			kind: &TypeKind{
				kind: build_prim_type((str)(PrimKind.Str)),
			},
			model: constant,
		}
	}

	fn lit_bool(self, lit: &LitExpr): &Data {
		let mut constant = new_bool(lit.value == (str)(TokenKind.True))
		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: constant,
			decl:     false,
			kind: &TypeKind{
				kind: build_prim_type((str)(PrimKind.Bool)),
			},
			model: constant,
		}
	}

	fn lit_rune(self, l: &LitExpr): &Data {
		const BYTE_KIND = (str)(PrimKind.U8)
		const RUNE_KIND = (str)(PrimKind.I32)

		let lt = l.value[1 : l.value.len-1] // Remove quotes.
		let r = to_rune(([]byte)(lt))
		let mut data = &Data{
			lvalue:   false,
			mutable:  false,
			constant: new_i64(i64(r)),
			decl:     false,
		}

		let (_, is_byte) = is_byte_lit(l.value)
		if is_byte {
			data.kind = &TypeKind{
				kind: build_prim_type(BYTE_KIND),
			}
		} else {
			data.kind = &TypeKind{
				kind: build_prim_type(RUNE_KIND),
			}
		}

		data.model = &RuneExprModel{code: r}
		data.is_rune = true
		ret data
	}

	fn lit_float(self, l: &LitExpr): &Data {
		const FLOAT_KIND = (str)(PrimKind.F64)

		let (f, _) = parse_float(l.value, 64)
		let mut constant = new_f64(f)

		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: constant,
			decl:     false,
			kind: &TypeKind{
				kind: build_prim_type(FLOAT_KIND),
			},
			model: constant,
		}
	}

	fn lit_int(self, l: &LitExpr): &Data {
		const BIT_SIZE = 0b01000000

		let mut lit = l.value
		let mut base = 0

		match {
		| lit.has_prefix("0x"): // Hexadecimal
			lit = lit[2:]
			base = 0b00010000

		| lit.has_prefix("0b"): // Binary
			lit = lit[2:]
			base = 0b10

		| lit[0] == '0' && lit.len > 1: // Octal
			lit = lit[1:]
			base = 0b1000

		|: // Decimal
			base = 0b1010
		}

		let mut d = &Data{
			lvalue:  false,
			mutable: false,
			decl:    false,
		}

		let mut value: any = nil
		let (sig, err) = parse_int(lit, base, BIT_SIZE)
		if err == ConvError.Ok {
			value = sig
			d.constant = new_i64(sig)
		} else {
			let (unsig, _) = parse_uint(lit, base, BIT_SIZE)
			d.constant = new_u64(unsig)
			value = unsig
		}

		d.kind = &TypeKind{
			kind: build_prim_type(kind_by_bitsize(value)),
		}

		normalize_bitsize(d)
		d.model = d.constant

		ret d
	}

	fn lit_num(self, l: &LitExpr): &Data {
		match {
		| is_float(l.value): ret self.lit_float(l)
		|:                   ret self.lit_int(l)
		}
	}

	fn eval_lit(self, lit: &LitExpr): &Data {
		match {
		| lit.is_nil():                      ret self.lit_nil()
		| is_str(lit.value):                 ret self.lit_str(lit)
		| is_bool(lit.value):                ret self.lit_bool(lit)
		| is_rune(lit.value):                ret self.lit_rune(lit)
		| std::jule::lex::is_num(lit.value): ret self.lit_num(lit)
		|:                                   ret new(Data)
		}
	}

	fn find_builtins(mut self, ident: str): any {
		match type self.lookup {
		| &ImportInfo:
			let mut def = find_builtins_import(ident, (&ImportInfo)(self.lookup))
			if def != nil {
				ret def
			}

		| &Sema:
			let mut def = find_builtins_sema(ident, (&Sema)(self.lookup))
			if def != nil {
				ret def
			}

		| &ScopeChecker:
			let mut def = find_builtins_sema(ident, (&ScopeChecker)(self.lookup).s)
			if def != nil {
				ret def
			}
		}

		ret find_builtin_def(ident)
	}

	fn get_def(mut self, ident: str, cpp_linked: bool): any {
		if !cpp_linked {
			let mut enm = self.lookup.find_enum(ident)
			if real(enm) {
				ret enm
			}
		}

		let mut v = self.lookup.find_var(ident, cpp_linked)
		if real(v) {
			ret v
		}

		let mut f = self.lookup.find_fn(ident, cpp_linked)
		if real(f) {
			ret f
		}

		let mut s = self.lookup.find_struct(ident, cpp_linked)
		if real(s) {
			ret s
		}

		let mut ta = self.lookup.find_type_alias(ident, cpp_linked)
		if real(ta) {
			ret ta
		}

		ret self.find_builtins(ident)
	}

	fn eval_enum(mut self, enm: &Enum, error_token: Token): &Data {
		if !self.s.is_accessible_define(enm.public, enm.token) {
			self.push_err(error_token, "ident_is_not_accessible", enm.ident)
			ret new(Data)
		}

		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: new(Const),
			decl:     true,
			kind: &TypeKind{
				kind: enm,
			},
		}
	}

	fn eval_struct(mut self, mut s: &StructIns, error_token: Token): &Data {
		if !self.s.is_accessible_define(s.decl.public, s.decl.token) {
			self.push_err(error_token, "ident_is_not_accessible", s.decl.ident)
			ret new(Data)
		}

		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: new(Const),
			decl:     true,
			kind: &TypeKind{
				kind: s,
			},
			model: s,
		}
	}

	fn eval_fn_ins(self, mut f: &FnIns): &Data {
		ret &Data{
			lvalue:   false,
			mutable:  false,
			constant: new(Const),
			decl:     false,
			kind: &TypeKind{
				kind: f,
			},
			model: f,
		}
	}

	fn eval_fn(mut self, mut f: &Fn, error_token: Token): &Data {
		if !self.s.is_accessible_define(f.public, f.token) {
			self.push_err(error_token, "ident_is_not_accessible", f.ident)
			ret new(Data)
		}

		let mut ins = f.instance()
		ret self.eval_fn_ins(ins)
	}

	// Checks owner illegal cycles.
	// Appends depend to depends if there is no illegal cycle.
	// Returns true if e.owner is nil.
	fn check_illegal_cycles(mut self, mut v: &Var, decl_token: Token): (ok: bool) {
		if !real(self.owner) {
			ret true
		}

		// Check illegal cycle for itself.
		// Because refers's owner is ta.
		if self.owner == v {
			self.push_err(self.owner.token, "illegal_cycle_refers_itself", self.owner.ident)
			ret false
		}

		const PADDING = 4

		let mut message = ""

		let push = fn(v1: &Var, v2: &Var) {
			let refers_to = errorf("refers_to", v1.ident, v2.ident)
			message = str_repeat(" ", PADDING) + refers_to + "\n" + message
		}

		// Check cross illegal cycle.
		let mut check_cross: fn(v: &Var): bool
		check_cross = fn(v: &Var): bool {
			for _, d in v.depends {
				if d == self.owner {
					push(v, d)
					ret false
				}

				if !check_cross(d) {
					push(v, d)
					ret false
				}
			}

			ret true
		}

		if !check_cross(v) {
			let mut err_msg = message
			message = ""
			push(self.owner, v)
			err_msg = err_msg + message
			self.push_err(decl_token, "illegal_cross_cycle", err_msg)
			ret false
		}

		self.owner.depends = append(self.owner.depends, v)
		ret true
	}

	fn eval_var(mut self, mut v: &Var, error_token: Token): &Data {
		if !self.s.is_accessible_define(v.public, v.token) {
			self.push_err(error_token, "ident_is_not_accessible", v.ident)
			ret new(Data)
		}

		v.used = true

		let ok = self.check_illegal_cycles(v, error_token)
		if !ok {
			ret new(Data)
		}

		if !v.cpp_linked && (!real(v.value) || !real(v.value.data)) {
			if v.constant {
				// Eval constant dependent variable.
				self.s.check_type_var(v, self.s)
				if !real(v.value.data) {
					// Skip error.
					ret new(Data)
				}
			}
		}

		if !real(v.kind) || !real(v.kind.kind) {
			ret new(Data)
		}

		let mut d = &Data{
			lvalue:  !v.constant,
			mutable: v.mutable,
			decl:    false,
			kind:    v.kind.kind.clone(),
			model:   v,
		}

		if !v.cpp_linked && v.is_initialized() && real(v.value.data) {
			d.is_rune = v.value.data.is_rune
		}

		if v.constant {
			d.constant = new(Const, v.value.data.constant)
			d.model = d.constant
		}

		if real(d.kind.fnc()) {
			let mut f = d.kind.fnc()
			if real(f.decl) {
				// Ignore identifier for non-anonymous (because has an identifier via variable).
				f.decl.ident = v.ident
			}
		}

		ret d
	}

	fn eval_type_alias(mut self, mut ta: &TypeAlias, error_token: Token): &Data {
		if !self.s.is_accessible_define(ta.public, ta.token) {
			self.push_err(error_token, "ident_is_not_accessible", ta.ident)
			ret new(Data)
		}

		ta.used = true

		let mut kind = ta.kind.kind.kind
		match type kind {
		| &StructIns:
			ret self.eval_struct((&StructIns)(kind), error_token)

		| &Enum:
			ret self.eval_enum((&Enum)(kind), error_token)

		| &Prim
		| &Slc:
			ret &Data{
				decl: true,
				kind: ta.kind.kind.clone(),
			}

		|:
			self.push_err(error_token, "invalid_expr")
			ret new(Data)
		}
	}

	fn eval_def(mut self, mut def: any, ident: Token): &Data {
		match type def {
		| &Var:
			ret self.eval_var((&Var)(def), ident)

		| &Enum:
			ret self.eval_enum((&Enum)(def), ident)

		| &Struct:
			ret self.eval_struct((&Struct)(def).instance(), ident)

		| &Fn:
			ret self.eval_fn((&Fn)(def), ident)

		| &FnIns:
			ret self.eval_fn_ins((&FnIns)(def))

		| &TypeAlias:
			ret self.eval_type_alias((&TypeAlias)(def), ident)

		|:
			self.push_err(ident, "ident_not_exist", ident.kind)
			ret new(Data)
		}
	}

	fn eval_ident(mut self, ident: &IdentExpr): &Data {
		let mut def = self.get_def(ident.ident, ident.cpp_linked)
		ret self.eval_def(def, ident.token)
	}

	fn eval_unary_minus(self, mut d: &Data): &Data {
		let t = d.kind.prim()
		if !real(t) || !is_num(t.to_str()) {
			ret new(Data)
		}

		if d.is_const() {
			match {
			| d.constant.is_f64(): d.constant.set_f64(-d.constant.read_f64())
			| d.constant.is_i64(): d.constant.set_f64(-d.constant.as_f64())
			| d.constant.is_u64(): d.constant.set_f64(-d.constant.as_f64())
			}
			normalize_type(d)
		}

		d.lvalue = false
		d.model = &UnaryExprModel{
			expr: d.model,
			op:   (str)(TokenKind.Minus),
		}
		ret d
	}

	fn eval_unary_plus(self, mut d: &Data): &Data {
		let t = d.kind.prim()
		if !real(t) || !is_num(t.to_str()) {
			ret new(Data)
		}

		if d.is_const() {
			match {
			| d.constant.is_f64(): d.constant.set_f64(+d.constant.read_f64())
			| d.constant.is_i64(): d.constant.set_f64(+d.constant.as_f64())
			| d.constant.is_u64(): d.constant.set_f64(+d.constant.as_f64())
			}
			normalize_type(d)
		}

		d.lvalue = false
		d.model = &UnaryExprModel{
			expr: d.model,
			op:   (str)(TokenKind.Plus),
		}
		ret d
	}

	fn eval_unary_caret(self, mut d: &Data): &Data {
		let t = d.kind.prim()
		if !real(t) || !is_int(t.to_str()) {
			ret new(Data)
		}

		if d.is_const() {
			match {
			| d.constant.is_i64():
				d.constant.set_i64(^d.constant.read_i64())

			| d.constant.is_u64():
				d.constant.set_u64(^d.constant.read_u64())
			}
		}

		d.lvalue = false
		d.model = &UnaryExprModel{
			expr: d.model,
			op:   (str)(TokenKind.Caret),
		}
		ret d
	}

	fn eval_unary_excl(self, mut d: &Data): &Data {
		let t = d.kind.prim()
		if !real(t) || !t.is_bool() {
			ret new(Data)
		}

		if d.is_const() {
			match {
			| d.constant.is_bool():
				d.constant.set_bool(!d.constant.read_bool())
			}
		}

		d.lvalue = false
		d.model = &UnaryExprModel{
			expr: d.model,
			op:   (str)(TokenKind.Excl),
		}
		ret d
	}

	fn eval_unary_star(mut self, mut d: &Data, op: Token): &Data {
		if !self.is_unsafe() {
			self.push_err(op, "unsafe_behavior_at_out_of_unsafe_scope")
		}

		let mut t = d.kind.ptr()
		if !real(t) || t.is_unsafe() {
			ret new(Data)
		}
		drop(d.constant)
		d.lvalue = true
		d.kind = t.elem
		d.model = &UnaryExprModel{
			expr: d.model,
			op:   (str)(TokenKind.Star),
		}
		ret d
	}

	fn eval_unary_amper(self, mut d: &Data): &Data {
		match type d.model {
		| &StructLitExprModel:
			let mut lit = (&StructLitExprModel)(d.model)
			d.kind = &TypeKind{
				kind: &Ref{
					elem: &TypeKind{kind: lit.strct},
				},
			}

			d.model = &AllocStructLitExprModel{
				lit: lit,
			}

		|:
			match {
			| real(d.kind.ref()):
				d.kind = &TypeKind{
					kind: &Ptr{elem: d.kind.ref().elem.clone()},
				}
				d.model = &GetRefPtrExprModel{
					expr: d.model,
				}

			| can_get_ptr(d):
				d.kind = &TypeKind{
					kind: &Ptr{elem: d.kind.clone()},
				}
				d.model = &UnaryExprModel{
					expr: d.model,
					op:   (str)(TokenKind.Amper),
				}

			|:
				drop(d)
			}
		}

		if real(d) {
			drop(d.constant)
			d.lvalue = true
			d.mutable = true
		}

		ret d
	}

	fn eval_unary(mut &self, mut u: &UnaryExpr): &Data {
		let mut d = self.eval_expr_kind(u.expr)
		if !real(d) {
			ret new(Data)
		}

		let mut cast_kind = d.cast_kind
		match u.op.kind {
		| (str)(TokenKind.Minus): d = self.eval_unary_minus(d)
		| (str)(TokenKind.Plus):  d = self.eval_unary_plus(d)
		| (str)(TokenKind.Caret): d = self.eval_unary_caret(d)
		| (str)(TokenKind.Excl):  d = self.eval_unary_excl(d)
		| (str)(TokenKind.Star):  d = self.eval_unary_star(d, u.op)
		| (str)(TokenKind.Amper): d = self.eval_unary_amper(d)
		|:               drop(d)
		}

		if !real(d) {
			self.push_err(u.op, "invalid_expr_unary_operator", u.op.kind)
		} else if d.is_const() {
			d.model = d.constant
		} else if real(cast_kind) {
			d.cast_kind = cast_kind
			apply_cast_kind(d)
		}

		ret d
	}

	fn eval_variadic(mut &self, mut v: &VariadicExpr): &Data {
		let mut d = self.eval_expr_kind(v.expr)
		if !real(d) {
			ret new(Data)
		}

		if real(d.kind.ref()) {
			d.kind = d.kind.ref().elem
			d.model = &ExplicitDerefExprModel{
				expr: d.model,
			}
		}

		if !is_variadicable(d.kind) {
			self.push_err(v.token, "variadic_with_non_variadicable", d.kind.to_str())
			ret new(Data)
		}

		d.variadiced = true
		d.kind = d.kind.slc().elem
		ret d
	}

	fn eval_unsafe(mut &self, mut u: &UnsafeExpr): &Data {
		let unsafety = self.unsafety
		self.unsafety = true

		let mut d = self.eval_expr_kind(u.expr)

		self.unsafety = unsafety

		ret d
	}

	fn eval_arr(mut &self, mut s: &SliceExpr): &Data {
		// Arrays always has type prefixes.
		let mut pt = self.prefix.arr()

		let mut arr = &Arr{
			auto: false,
			n:    0,
			elem: pt.elem,
		}

		if pt.auto {
			arr.n = s.elems.len
		} else {
			arr.n = s.elems.len
			if arr.n > pt.n {
				self.push_err(s.token, "overflow_limits")
			} else if arr.n < pt.n {
				arr.n = pt.n
			}
		}

		let mut model = &ArrayExprModel{
			kind:  arr,
			elems: make([]ExprModel, s.elems.len),
		}

		let mut prefix = self.prefix
		self.prefix = arr.elem
		for (i, mut elem) in s.elems {
			let mut d = self.eval_expr_kind(elem)
			if !real(d) {
				continue
			}

			self.s.check_assign_type(arr.elem, d, s.token, true)
			model.elems[i] = d.model
		}
		self.prefix = prefix

		ret &Data{
			mutable: true,
			kind:    &TypeKind{kind: arr},
			model:   model,
		}
	}

	fn eval_exp_slc(mut &self, mut s: &SliceExpr, elem_type: &TypeKind): &Data {
		let mut slc = &Slc{
			elem: elem_type,
		}

		let mut model = &SliceExprModel{
			elem_kind: elem_type,
			elems:     make([]ExprModel, s.elems.len),
		}

		let mut prefix = self.prefix
		self.prefix = slc.elem
		for (i, mut elem) in s.elems {
			let mut d = self.eval_expr_kind(elem)
			if !real(d) {
				continue
			}

			self.s.check_assign_type(slc.elem, d, s.token, true)
			model.elems[i] = d.model
		}
		self.prefix = prefix

		ret &Data{
			mutable: true,
			kind:    &TypeKind{kind: slc},
			model:   model,
		}
	}

	fn eval_slice_expr(mut &self, mut s: &SliceExpr): &Data {
		if real(self.prefix) {
			match {
			| real(self.prefix.arr()):
				ret self.eval_arr(s)

			| real(self.prefix.slc()):
				let mut pt = self.prefix.slc()
				ret self.eval_exp_slc(s, pt.elem)
			}
		}

		let mut prefix = self.prefix
		drop(self.prefix)

		if s.elems.len == 0 {
			self.push_err(s.token, "dynamic_type_annotation_failed")
			ret new(Data)
		}

		let mut first_elem = self.eval_expr_kind(s.elems[0])
		if !real(first_elem) {
			ret new(Data)
		}

		let mut d = self.eval_exp_slc(s, first_elem.kind)

		self.prefix = prefix
		ret d
	}

	fn check_integer_indexing_by_data(mut self, mut d: &Data, token: Token) {
		let err_key = check_data_for_integer_indexing(d)
		if err_key != "" {
			self.push_err(token, err_key)
		}
	}

	fn indexing_ptr(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
		self.check_integer_indexing_by_data(index, i.token)

		let mut ptr = d.kind.ptr()
		match {
		| ptr.is_unsafe():
			self.push_err(i.token, "unsafe_ptr_indexing")
			ret

		| !self.is_unsafe():
			self.push_err(i.token, "unsafe_behavior_at_out_of_unsafe_scope")
		}

		d.kind = ptr.elem.clone()
	}

	fn indexing_arr(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
		let mut arr = d.kind.arr()
		d.kind = arr.elem.clone()
		self.check_integer_indexing_by_data(index, i.token)
	}

	fn indexing_slc(mut self, mut d: &Data,mut index: &Data, i: &IndexingExpr) {
		let mut slc = d.kind.slc()
		d.kind = slc.elem.clone()
		self.check_integer_indexing_by_data(index, i.token)
	}

	fn indexing_map(mut self, mut d: &Data, mut index: &Data, mut i: &IndexingExpr) {
		if !real(index) {
			ret
		}

		let mut m = d.kind.map()
		let mut atc = AssignTypeChecker{
			s:           self.s,
			dest:        m.key,
			d:           index,
			error_token: i.token,
			deref:       true,
		}
		_ = atc.check()

		d.kind = m.val.clone()
	}

	fn indexing_str(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
		const BYTE_KIND = (str)(PrimKind.U8)
		d.kind.kind = build_prim_type(BYTE_KIND)

		if !real(index) {
			ret
		}

		self.check_integer_indexing_by_data(index, i.token)

		if !index.is_const() {
			drop(d.constant)
			ret
		}

		if d.is_const() {
			let error_token = i.token
			let i = index.constant.as_i64()
			let s = d.constant.read_str()
			if int(i) >= s.len {
				self.push_err(error_token, "overflow_limits")
			} else {
				d.constant.set_u64(u64(s[i]))
			}
		}
	}

	fn to_indexing(mut self, mut d: &Data, mut index: &Data, mut i: &IndexingExpr) {
		match {
		| real(d.kind.ptr()):
			self.indexing_ptr(d, index, i)
			ret

		| real(d.kind.arr()):
			self.indexing_arr(d, index, i)
			ret

		| real(d.kind.slc()):
			self.indexing_slc(d, index, i)
			ret

		| real(d.kind.map()):
			self.indexing_map(d, index, i)
			ret

		| real(d.kind.prim()):
			let prim = d.kind.prim()
			match {
			| prim.is_str():
				self.indexing_str(d, index, i)
				ret
			}
		}

		self.push_err(i.token, "not_supports_indexing", d.kind.to_str())
	}

	fn eval_indexing(mut &self, mut i: &IndexingExpr): &Data {
		let mut d = self.eval_expr_kind(i.expr)
		if !real(d) {
			ret new(Data)
		}

		let mut expr_model = d.model
		let mut index = self.eval_expr_kind(i.index)
		self.to_indexing(d, index, i)

		if real(index) {
			if d.is_const() {
				d.model = d.constant
			} else {
				d.model = &IndexigExprModel{
					expr:  expr_model,
					index: index.model,
				}
			}
		}

		ret d
	}

	// Returns left and right index values.
	// Returns zero integer expression if slicing have not left index.
	// So, left index always represents an expression.
	// Left data is nil if expression eval failed.
	fn eval_slicing_exprs(mut &self, mut s: &SlicingExpr): (&Data, &Data) {
		let mut l = new(Data)
		let mut r = new(Data)

		if s.start != nil {
			l = self.eval_expr_kind(s.start)
			if real(l) {
				self.check_integer_indexing_by_data(l, s.token)
			} else {
				ret new(Data), new(Data)
			}
		} else {
			l = &Data{
				constant: new_i64(0),
				kind:     &TypeKind{kind: build_prim_type(SYS_INT)},
			}
			l.model = l.constant
		}

		if s.to != nil {
			r = self.eval_expr_kind(s.to)
			if real(r) {
				self.check_integer_indexing_by_data(r, s.token)
			} else {
				ret new(Data), new(Data)
			}
		}

		ret l, r
	}

	fn slicing_arr(self, mut d: &Data) {
		let mut elem_type = d.kind.arr().elem.clone()
		d.kind.kind = &Slc{elem: elem_type}

		d.lvalue = false

		// Keep mutability id already mutable.
		// Be mutable, if element is not mutable-type.
		d.mutable = d.mutable || !is_mut(elem_type)
	}

	fn slicing_slc(self, mut d: &Data) {
		d.lvalue = false
	}

	fn slicing_str(self, mut d: &Data, l: &Data, r: &Data) {
		d.lvalue = false
		d.mutable = true
		if !d.is_const() {
			ret
		}

		if !real(l) || !real(r) {
			drop(d.constant)
			ret
		}

		if l.is_const() && r.is_const() {
			let left = l.constant.as_i64()
			if left < 0 {
				ret
			}

			let s = d.constant.read_str()
			let mut right: i64 = 0
			if !real(r) {
				right = i64(s.len)
			} else {
				right = r.constant.as_i64()
			}

			if left > right {
				ret
			}
			d.constant.set_str(s[left:right])
		} else {
			drop(d.constant)
		}
	}

	fn check_slicing(mut self, mut d: &Data, l: &Data, r: &Data, s: &SlicingExpr) {
		match {
		| real(d.kind.arr()):
			self.slicing_arr(d)
			ret

		| real(d.kind.slc()):
			self.slicing_slc(d)
			ret

		| real(d.kind.prim()):
			let prim = d.kind.prim()
			match {
			| prim.is_str():
				self.slicing_str(d, l, r)
				ret
			}
		}

		self.push_err(s.token, "not_supports_slicing", d.kind.to_str())
	}

	fn eval_slicing(mut &self, mut s: &SlicingExpr): &Data {
		let mut d = self.eval_expr_kind(s.expr)
		if !real(d) {
			ret new(Data)
		}

		let (mut l, mut r) = self.eval_slicing_exprs(s)
		if !real(l) {
			ret d
		}

		self.check_slicing(d, l, r, s)
		drop(d.cast_kind)

		let mut model = &SlicingExprModel{
			expr: d.model,
			left: l.model,
		}

		if real(r) {
			model.right = r.model
		}

		d.model = model
		ret d
	}

	fn cast_ptr(mut self, t: &TypeKind, mut d: &Data, error_token: Token) {
		if !self.is_unsafe() {
			self.push_err(error_token, "unsafe_behavior_at_out_of_unsafe_scope")
			ret
		}

		let prim = d.kind.prim()
		if !real(d.kind.ptr()) && (!real(prim) || !is_int(prim.to_str())) {
			self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
		}

		drop(d.constant)
	}

	fn cast_struct(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
		let mut tr = d.kind.trt()
		if !real(tr) {
			self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
			ret
		}

		let mut s = new(StructIns)
		if real(t.ref()) {
			s = t.ref().elem.strct()
		} else {
			s = t.strct()
		}
		if !s.decl.is_implements(tr) {
			self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
		}
	}

	fn cast_ref(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
		let mut ref = t.ref()
		if real(ref.elem.strct()) {
			self.cast_struct(t, d, error_token)
			ret
		}

		self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
	}

	fn cast_slc(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
		if real(d.kind.enm()) {
			if !real(d.kind.enm().kind.kind.prim()) || !d.kind.enm().kind.kind.prim().is_str() {
				self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
				ret
			}
		} else if !real(d.kind.prim()) || !d.kind.prim().is_str() {
			self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
			ret
		}

		t = t.slc().elem
		let prim = t.prim()
		if !real(prim) || (!prim.is_u8() && !prim.is_i32()) {
			self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
		}
	}

	fn cast_str(mut self, mut d: &Data, error_token: Token) {
		if real(d.kind.enm()) {
			let mut e = d.kind.enm()
			if real(e.kind.kind.prim()) && e.kind.kind.prim().is_str() {
				ret
			}
		}

		if real(d.kind.prim()) {
			let prim = d.kind.prim()
			if !prim.is_u8() && !prim.is_i32() {
				self.push_err(error_token, "type_not_supports_casting_to", (str)(PrimKind.Str), d.kind.to_str())
			}
			ret
		}

		if !real(d.kind.slc()) {
			self.push_err(error_token, "type_not_supports_casting_to", (str)(PrimKind.Str), d.kind.to_str())
			ret
		}

		let mut t = d.kind.slc().elem
		let prim = t.prim()
		if !real(prim) || (!prim.is_u8() && !prim.is_i32()) {
			self.push_err(error_token, "type_not_supports_casting_to", (str)(PrimKind.Str), d.kind.to_str())
		}
	}

	fn cast_int(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
		if d.is_const() {
			let prim = t.prim()
			match {
			| is_sig_int(prim.kind):
				d.constant.set_i64(d.constant.as_i64())

			| is_unsig_int(prim.kind):
				d.constant.set_u64(d.constant.as_u64())
			}
		}

		if real(d.kind.enm()) {
			let e = d.kind.enm()
			if is_num(e.kind.kind.to_str()) {
				ret
			}
		}

		if real(d.kind.ptr()) {
			let prim = t.prim()
			if prim.is_uintptr() {
				// Ignore case.
			} else if !self.is_unsafe() {
				self.push_err(error_token, "unsafe_behavior_at_out_of_unsafe_scope")
			} else if !prim.is_i32() && !prim.is_i64() && !prim.is_u16() && !prim.is_u32() && !prim.is_u64() {
				self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
			}
			ret
		}

		let prim = d.kind.prim()
		if real(prim) && is_num(prim.to_str()) {
			ret
		}

		self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
	}

	fn cast_num(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
		if d.is_const() {
			let prim = t.prim()
			match {
			| is_float(prim.kind):
				d.constant.set_f64(d.constant.as_f64())

			| is_sig_int(prim.kind):
				d.constant.set_i64(d.constant.as_i64())

			| is_unsig_int(prim.kind):
				d.constant.set_u64(d.constant.as_u64())
			}
		}

		if real(d.kind.enm()) {
			let e = d.kind.enm()
			if is_num(e.kind.kind.to_str()) {
				ret
			}
		}

		let prim = d.kind.prim()
		if real(prim) && is_num(prim.to_str()) {
			ret
		}

		self.push_err(error_token, "type_not_supports_casting_to", d.kind.to_str(), t.to_str())
	}

	fn cast_prim(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
		let prim = t.prim()
		match {
		| prim.is_any():
			// The any type supports casting to any data type.

		| prim.is_str():
			self.cast_str(d, error_token)

		| is_int(prim.to_str()):
			self.cast_int(t, d, error_token)

		| is_num(prim.to_str()):
			self.cast_num(t, d, error_token)

		|:
			self.push_err(error_token, "type_not_supports_casting", t.to_str())
		}
	}

	fn eval_cast_by_type_n_data(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token): &Data {
		match {
		| real(d.kind.prim()) && d.kind.prim().is_any():
			// The any type supports casting to any data type.

		| real(t.ptr()):
			self.cast_ptr(t, d, error_token)

		| real(t.ref()):
			self.cast_ref(t, d, error_token)

		| real(t.slc()):
			self.cast_slc(t, d, error_token)

		| real(t.strct()):
			self.cast_struct(t, d, error_token)

		| real(t.prim()):
			self.cast_prim(t, d, error_token)

		|:
			self.push_err(error_token, "type_not_supports_casting", t.to_str())
			drop(d)
		}

		if !real(d) {
			ret new(Data)
		}

		// Keep mutability if data is already mutable.
		// Even if the data is not mutable, set as mutable if the type is not mutable-type.
		d.mutable = d.mutable || !is_mut(t)

		d.lvalue = is_lvalue(t)
		d.decl = false
		if real(t.prim()) && d.is_const() {
			d.model = d.constant
		}

		if !real(d.kind.enm()) || d.kind.enm().kind.kind.to_str() != t.to_str() {
			d.cast_kind = t
			//d.Kind = t // Do not this, will be set automatically end of the eval.
		} else {
			d.kind = t
		}

		ret d
	}

	fn eval_cast(mut &self, mut c: &CastExpr): &Data {
		let mut t = build_type(c.kind)
		let ok = self.s.check_type(t, self.lookup)
		if !ok {
			ret new(Data)
		}

		let mut d = self.eval_expr_kind(c.expr)
		if !real(d) {
			ret new(Data)
		}

		d = self.eval_cast_by_type_n_data(t.kind, d, c.kind.token)

		ret d
	}

	fn eval_ns_selection(mut self, s: &NsSelectionExpr): &Data {
		let path = build_link_path_by_tokens(s.ns)
		let mut imp = self.lookup.select_package(fn(p: &ImportInfo): bool {
			ret p.link_path == path
		})

		if !real(imp) || !imp.is_lookupable((str)(TokenKind.Self)) {
			self.push_err(s.ident, "namespace_not_exist", path)
			ret new(Data)
		}

		let mut lookup = self.lookup
		self.lookup = imp

		const CPP_LINKED = false
		let mut def = self.get_def(s.ident.kind, CPP_LINKED)
		let mut d = self.eval_def(def, s.ident)

		self.lookup = lookup

		ret d
	}

	fn eval_struct_lit_explicit(mut &self, mut s: &StructIns, mut exprs: []ExprData, error_token: Token): &Data {
		let ok = self.s.check_generic_quantity(s.decl.generics.len, s.generics.len, error_token)
		if !ok {
			ret new(Data)
		}
		// NOTE: Instance already checked (just fields) if generic quantity passes.

		let mut slc = StructLitChecker{
			e:           self,
			error_token: error_token,
			s:           s,
		}
		slc.check(exprs)

		ret &Data{
			mutable: true,
			kind:    &TypeKind{kind: s},
			model: &StructLitExprModel{
				strct: s,
				args:  slc.args,
			},
		}
	}

	fn eval_struct_lit(mut &self, mut lit: &StructLit): &Data {
		let mut t = build_type(lit.kind)
		let ok = self.s.check_type(t, self.lookup)
		if !ok {
			ret new(Data)
		}

		let mut s = t.kind.strct()
		if !real(s) {
			self.push_err(lit.kind.token, "invalid_syntax")
			ret new(Data)
		}

		ret self.eval_struct_lit_explicit(s, lit.exprs, lit.kind.token)
	}

	fn eval_type(mut self, mut t: &TypeDecl): &Data {
		let mut tk = build_type(t)
		let ok = self.s.check_type(tk, self.lookup)
		if !ok {
			ret new(Data)
		}

		ret &Data{
			decl:  true,
			kind:  tk.kind,
			model: tk.kind,
		}
	}

	fn call_type_fn(mut &self, mut fc: &FnCallExpr, mut d: &Data): &Data {
		if fc.generics.len > 0 {
			self.push_err(fc.token, "type_not_supports_generics", d.kind.to_str())
		} else if fc.args.len < 1 {
			self.push_err(fc.token, "missing_expr_for", "v")
		} else if fc.args.len > 1 {
			self.push_err(fc.args[1].token, "argument_overflow")
		}

		if fc.args.len > 0 {
			let mut arg = self.eval_expr_kind(fc.args[0].kind)

			// Skip strings beceause string constructor
			// takes any type.
			let prim = d.kind.prim()
			if real(prim) && prim.is_str() {
				d.model = &StrConstructorCallExprModel{
					expr: arg.model,
				}
				goto _ret
			}

			if real(arg) {
				d = self.eval_cast_by_type_n_data(d.kind, arg, fc.args[0].token)
			}
		}

	_ret:
		d.decl = false
		ret d
	}

	fn check_fn_call_generics(mut self, mut f: &FnIns,
		mut fc: &FnCallExpr): (ok: bool, dynamic_annotation: bool) {
		match {
		| f.decl.generics.len > 0 && fc.generics.len == 0 && f.params.len > 0:
			dynamic_annotation = true
			// Make empty types to generics for ordering.
			f.generics = make([]&TypeKind, f.decl.generics.len)
			ret true, true

		| !self.s.check_generic_quantity(f.decl.generics.len, fc.generics.len, fc.token):
			ret false, false

		|:
			// Build real kinds of generic types.
			f.generics = make([]&TypeKind, f.decl.generics.len)
			for (i, mut g) in fc.generics {
				let mut k = build_type(g)
				let ok = self.s.check_type(k, self.lookup)
				if !ok {
					ret false, false
				}
				f.generics[i] = k.kind
			}

			ret true, false
		}
	}

	fn call_builtin_fn(mut &self, mut fc: &FnCallExpr, mut d: &Data): &Data {
		let mut f = d.kind.fnc()

		d = f.caller(self, fc, d)
		if !real(d) {
			ret new(Data)
		}

		d.mutable = true
		ret d
	}

	fn call_fn(mut &self, mut fc: &FnCallExpr, mut d: &Data): &Data {
		let mut f = d.kind.fnc()
		if f.is_builtin() {
			ret self.call_builtin_fn(fc, d)
		}

		let mut old = self.s
		if real(f.decl.owner) {
			self.s = f.decl.owner.sema
		}

		defer {
			if old != self.s {
				old.errors = append(old.errors, self.s.errors...)
			}
			self.s = old
		}()

		if !d.mutable && f.decl.is_method() && f.decl.params[0].mutable {
			self.push_err(fc.token, "mutable_operation_on_immutable")
		} else if !self.is_unsafe() && f.decl.unsafety {
			self.push_err(fc.token, "unsafe_behavior_at_out_of_unsafe_scope")
		}

		let (mut ok, dynamic_annotation) = self.check_fn_call_generics(f, fc)
		if !ok {
			ret new(Data)
		}

		if !dynamic_annotation {
			let ok = self.s.reload_fn_ins_types(f)
			if !ok {
				ret new(Data)
			}
		} else {
			self.s.build_fn_non_generic_type_kinds(f, false)
		}

		let mut fcac = FnCallArgChecker{
			e:                  self,
			f:                  f,
			args:               fc.args,
			dynamic_annotation: dynamic_annotation,
			error_token:        fc.token,
		}
		if real(f.decl.owner) {
			old, self.s = self.s, old // Save current Sema.
			ok = fcac.check()
			old, self.s = self.s, old // Save owner Sema.
		} else {
			ok = fcac.check()
		}

		if !ok && dynamic_annotation {
			ret new(Data)
		}

		let (is_unique_ins, pos) = f.decl.append_instance(f)
		if pos != -1 {
			f = f.decl.instances[pos]
		}

		let mut call_model = d.model

		if f.decl.is_void() {
			d = build_void_data()
		} else {
			if dynamic_annotation {
				ok = self.s.reload_fn_ins_types(f)
				if !ok {
					ret new(Data)
				}
			}

			d.kind = f.result
			d.lvalue = is_lvalue(f.result)
		}

		d.mutable = true
		d.model = &FnCallExprModel{
			func:  f,
			is_co: fc.concurrent,
			expr:  call_model,
			args:  fcac.arg_models,
		}

		if f.generics.len > 0 && is_unique_ins {
			// Check generic function instance instantly.
			self.s.check_fn_ins(f)
		}

		ret d
	}

	fn eval_fn_call(mut &self, mut fc: &FnCallExpr): &Data {
		let mut d = self.eval_expr_kind(fc.expr.kind)
		if !real(d) {
			ret new(Data)
		}

		if d.decl {
			ret self.call_type_fn(fc, d)
		}

		if !real(d.kind.fnc()) {
			self.push_err(fc.token, "invalid_syntax")
			ret new(Data)
		}

		ret self.call_fn(fc, d)
	}

	fn eval_enum_static(mut self, mut enm: &Enum, ident: Token): &Data {
		let mut d = &Data{
			lvalue:  false,
			decl:    false,
			mutable: false,
			kind:    &TypeKind{kind: enm},
		}

		let mut item = enm.find_item(ident.kind)
		if !real(item) {
			self.push_err(ident, "obj_have_not_ident", ident.kind)
		} else {
			d.constant = new(Const, item.value.data.constant)
			d.model = d.constant
		}

		ret d
	}

	fn eval_trait_sub_ident(mut self, d: &Data, mut trt: &Trait, ident: Token): &Data {
		let mut f = trt.find_method(ident.kind)
		if !real(f) {
			self.push_err(ident, "obj_have_not_ident", ident.kind)
			ret new(Data)
		}

		let mut model: any = nil
		if &trt == &BUILTIN_TRAIT_ERROR {
			model = &BuiltinErrorTraitSubIdentExprModel{
				expr:  d.model,
				ident: ident.kind,
			}
		} else {
			model = &TraitSubIdentExprModel{
				expr:  d.model,
				ident: ident.kind,
			}
		}

		ret &Data{
			lvalue:   false,
			decl:     false,
			mutable:  false,
			kind:     &TypeKind{kind: f.instance()},
			model:    model,
		}
	}

	fn eval_struct_sub_ident(mut self, mut d: &Data, mut s: &StructIns, si: &SubIdentExpr, ref: bool): &Data {
		let mut f = s.find_field(si.ident.kind)
		if real(f) {
			if !self.s.is_accessible_define(f.decl.public, f.decl.token) {
				self.push_err(si.ident, "ident_is_not_accessible", f.decl.ident)
			}

			let mut model = &StructSubIdentExprModel{
				expr_kind: d.kind,
				expr:      d.model,
				field:     f,
			}
			d.model = model
			d.kind = f.kind.clone()

			if f.decl.mutable && !d.mutable {
				// Interior mutability.
				match type self.lookup {
				| &ScopeChecker:
					let scope = (&ScopeChecker)(self.lookup)
					d.mutable = real(scope.owner) && &scope.owner.owner == &s
					if d.mutable {
						let mut v = new(Var, (&Var)(model.expr))
						v.mutable = true
						model.expr = v
					}
				}
			}

			ret d
		}

		let mut m = s.find_method(si.ident.kind)
		if !real(m) {
			self.push_err(si.ident, "obj_have_not_ident", si.ident.kind)
			ret new(Data)
		}

		if m.params[0].is_ref() && !ref {
			self.push_err(si.ident, "ref_method_used_with_not_ref_instance")
		}

		let mut ins = m.instance()
		ins.owner = s
		d.model = &StructSubIdentExprModel{
			expr_kind: d.kind,
			expr:      d.model,
			method:    ins,
		}
		d.kind = &TypeKind{kind: ins}
		ret d
	}

	fn eval_slice_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
		match ident.kind {
		| "len":
			ret &Data{
				mutable: false,
				kind:    &TypeKind{kind: build_prim_type(SYS_INT)},
				model:   &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "len()",
				},
			}
	
		| "cap":
			ret &Data{
				mutable: false,
				kind:    &TypeKind{kind: build_prim_type(SYS_INT)},
				model:   &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "cap()",
				},
			}
	
		|:
			self.push_err(ident, "obj_have_not_ident", ident.kind)
			ret new(Data)
		}
	}

	fn eval_array_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
		match ident.kind {
		| "len":
			let mut c = new_i64(i64(d.kind.arr().n))
			ret &Data{
				constant: c,
				mutable:  false,
				kind:     &TypeKind{kind: build_prim_type(SYS_INT)},
				model:    c,
			}

		|:
			self.push_err(ident, "obj_have_not_ident", ident.kind)
			ret new(Data)
		}
	}

	fn eval_map_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
		match ident.kind {
		| "len":
			ret &Data{
				mutable: false,
				kind:    &TypeKind{kind: build_prim_type(SYS_INT)},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "len()",
				},
			}

		| "clear":
			ret &Data{
				mutable: d.mutable,
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common_mut,
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "clear",
				},
			}

		| "keys":
			let mut m = d.kind.map()
			ret &Data{
				mutable: d.mutable,
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common_mut,
						result: &TypeKind{
							kind: &Slc{
								elem: m.key,
							},
						},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "keys",
				},
			}

		| "values":
			let mut m = d.kind.map()
			ret &Data{
				mutable: d.mutable,
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common_mut,
						result: &TypeKind{
							kind: &Slc{
								elem: m.val,
							},
						},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "values",
				},
			}

		| "has":
			let mut m = d.kind.map()
			ret &Data{
				mutable: d.mutable,
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "key",
								},
								kind: m.key,
							},
						],
						result: &TypeKind{kind: build_prim_type((str)(PrimKind.Bool))},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "has",
				},
			}

		| "del":
			let mut m = d.kind.map()
			ret &Data{
				mutable: d.mutable,
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common_mut,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "key",
								},
								kind: m.key,
							},
						],
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "del",
				},
			}

		|:
			self.push_err(ident, "obj_have_not_ident", ident.kind)
			ret new(Data)
		}
	}

	fn eval_str_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
		match ident.kind {
		| "len":
			ret &Data{
				mutable: false,
				kind:    &TypeKind{kind: build_prim_type(SYS_INT)},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "len()",
				},
			}

		| "has_prefix":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "sub",
								},
								kind: d.kind,
							},
						],
						result: &TypeKind{kind: build_prim_type((str)(PrimKind.Bool))},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "has_prefix",
				},
			}

		| "has_suffix":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "sub",
								},
								kind: d.kind,
							},
						],
						result: &TypeKind{kind: build_prim_type((str)(PrimKind.Bool))},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "has_suffix",
				},
			}

		| "find":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "sub",
								},
								kind: d.kind,
							},
						],
						result: &TypeKind{kind: build_prim_type((str)(PrimKind.Int))},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "find",
				},
			}

		| "rfind":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "sub",
								},
								kind: d.kind,
							},
						],
						result: &TypeKind{kind: build_prim_type((str)(PrimKind.Int))},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "rfind",
				},
			}

		| "trim":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "bytes",
								},
								kind: d.kind,
							},
						],
						result: d.kind,
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "trim",
				},
			}

		| "rtrim":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "bytes",
								},
								kind: d.kind,
							},
						],
						result: d.kind,
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "rtrim",
				},
			}

		| "split":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "sub",
								},
								kind: d.kind,
							},
							&ParamIns{
								decl: &Param{
									ident: "n",
								},
								kind: &TypeKind{kind: build_prim_type((str)(PrimKind.Int))},
							},
						],
						result: &TypeKind{
							kind: &Slc{
								elem: d.kind,
							},
						},
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "split",
				},
			}

		| "replace":
			ret &Data{
				kind: &TypeKind{
					kind: &FnIns{
						caller: builtin_caller_common,
						params: [
							&ParamIns{
								decl: &Param{
									ident: "sub",
								},
								kind: d.kind,
							},
							&ParamIns{
								decl: &Param{
									ident: "new",
								},
								kind: d.kind,
							},
							&ParamIns{
								decl: &Param{
									ident: "n",
								},
								kind: &TypeKind{kind: build_prim_type((str)(PrimKind.Int))},
							},
						],
						result: d.kind,
					},
				},
				model: &CommonSubIdentExprModel{
					expr:  d.model,
					ident: "replace",
				},
			}

		|:
			self.push_err(ident, "obj_have_not_ident", ident.kind)
			ret new(Data)
		}
	}

	fn eval_int_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.Int)

		match ident.kind {
		| "MAX":
			let mut c = new_i64(i64(max_of(kind)))
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_i64(i64(min_of(kind)))
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_uint_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.Uint)

		match ident.kind {
		| "MAX":
			let mut c = new_u64(u64(max_of(kind)))
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_i8_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.I8)
		const min = MIN_I8
		const max = MAX_I8

		match ident.kind {
		| "MAX":
			let mut c = new_i64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_i64(min)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_i16_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.I16)
		const min = MIN_I16
		const max = MAX_I16

		match ident.kind {
		| "MAX":
			let mut c = new_i64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_i64(min)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_i32_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.I32)
		const min = MIN_I32
		const max = MAX_I32

		match ident.kind {
		| "MAX":
			let mut c = new_i64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_i64(min)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_i64_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.I64)
		const min = MIN_I64
		const max = MAX_I64

		match ident.kind {
		| "MAX":
			let mut c = new_i64(min)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_i64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_u8_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.U8)
		const max = MAX_U8

		match ident.kind {
		| "MAX":
			let mut c = new_u64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_u16_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.U16)
		const max = MAX_U16

		match ident.kind {
		| "MAX":
			let mut c = new_u64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_u32_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.U32)
		const max = MAX_U32

		match ident.kind {
		| "MAX":
			let mut c = new_u64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_u64_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.U64)
		const max = MAX_U64

		match ident.kind {
		| "MAX":
			let mut c = new_u64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_f32_type_tatic(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.F32)
		const max = MAX_F32
		const min = MIN_F32

		match ident.kind {
		| "MAX":
			let mut c = new_f64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_f64(min)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_f64_type_static(mut self, ident: Token): &Data {
		const kind = (str)(PrimKind.F64)
		const max = MAX_F64
		const min = MIN_F64

		match ident.kind {
		| "MAX":
			let mut c = new_f64(max)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		| "MIN":
			let mut c = new_f64(min)
			ret &Data{
				constant: c,
				model:    c,
				kind:     &TypeKind{kind: build_prim_type(kind)},
			}

		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_prim_static(mut self, kind: str, ident: Token): &Data {
		match kind {
		| (str)(PrimKind.Int):  ret self.eval_int_type_static(ident)
		| (str)(PrimKind.Uint): ret self.eval_uint_type_static(ident)
		| (str)(PrimKind.I8):   ret self.eval_i8_type_static(ident)
		| (str)(PrimKind.I16):  ret self.eval_i16_type_static(ident)
		| (str)(PrimKind.I32):  ret self.eval_i32_type_static(ident)
		| (str)(PrimKind.I64):  ret self.eval_i64_type_static(ident)
		| (str)(PrimKind.U8):   ret self.eval_u8_type_static(ident)
		| (str)(PrimKind.U16):  ret self.eval_u16_type_static(ident)
		| (str)(PrimKind.U32):  ret self.eval_u32_type_static(ident)
		| (str)(PrimKind.U64):  ret self.eval_u64_type_static(ident)
		| (str)(PrimKind.F32):  ret self.eval_f32_type_tatic(ident)
		| (str)(PrimKind.F64):  ret self.eval_f64_type_static(ident)
		|:
			self.push_err(ident, "type_have_not_ident", kind, ident.kind)
			ret new(Data)
		}
	}

	fn eval_type_static(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
		match {
		| real(d.kind.prim()):
			ret self.eval_prim_static(d.kind.prim().to_str(), si.ident)

		| real(d.kind.enm()):
			ret self.eval_enum_static(d.kind.enm(), si.ident)

		|:
			self.push_err(si.ident, "type_not_support_sub_fields", d.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_obj_sub_ident(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
		let mut kind = d.kind
		if real(d.kind.ptr()) {
			let ptr = d.kind.ptr()
			if !ptr.is_unsafe() {
				if !si.is_self && !self.is_unsafe() {
					self.push_err(si.ident, "unsafe_behavior_at_out_of_unsafe_scope")
				}
				kind = d.kind.ptr().elem
			}
		} else if real(d.kind.ref()) {
			kind = d.kind.ref().elem
		}

		match {
		| real(d.kind.trt()):
			ret self.eval_trait_sub_ident(d, d.kind.trt(), si.ident)

		| real(kind.strct()):
			let s = kind.strct()
			if is_instanced_struct(s) {
				let mut used_reference_elem = real(d.kind.ref())
				ret self.eval_struct_sub_ident(d, kind.strct(), si, used_reference_elem)
			}

		| real(kind.slc()):
			ret self.eval_slice_sub_ident(d, si.ident)

		| real(kind.arr()):
			ret self.eval_array_sub_ident(d, si.ident)

		| real(kind.map()):
			ret self.eval_map_sub_ident(d, si.ident)

		| real(kind.prim()):
			let p = kind.prim()
			match p.kind {
			| (str)(PrimKind.Str):
				ret self.eval_str_sub_ident(d, si.ident)
			}
		}

		self.push_err(si.ident, "obj_not_support_sub_fields", d.kind.to_str())
		ret new(Data)
	}

	fn eval_sub_ident(mut &self, mut si: &SubIdentExpr): &Data {
		let mut d = self.eval_expr_kind(si.expr)
		if !real(d) {
			ret new(Data)
		}

		if d.decl {
			ret self.eval_type_static(d, si)
		}

		ret self.eval_obj_sub_ident(d, si)
	}

	fn eval_tuple(mut &self, mut tup: &TupleExpr): &Data {
		let mut tup_t = &Tuple{}
		tup_t.types = make([]&TypeKind, tup.expr.len)

		let mut model = &TupleExprModel{
			datas: make([]&Data, tup.expr.len),
		}

		let mut ok = true
		for (i, mut expr) in tup.expr {
			let mut d = self.eval_expr_kind(expr)
			if !real(d) {
				ok = false
				continue
			}
			tup_t.types[i] = d.kind
			model.datas[i] = d
		}

		if !ok {
			ret new(Data)
		}

		ret &Data{
			kind:  &TypeKind{kind: tup_t},
			model: model,
		}
	}

	fn eval_map(mut &self, mut m: &Map, mut lit: &BraceLit): &Data {
		let mut model = &MapExprModel{
			key_kind: m.key,
			val_kind: m.val,
		}

		for (_, mut expr) in lit.exprs {
			match type expr {
			| &KeyValPair:
				// Ok.

			|:
				self.push_err(lit.token, "invalid_syntax")
				ret new(Data)
			}

			let mut pair = (&KeyValPair)(expr)

			let mut key = self.eval_expr_kind(pair.key)
			if !real(key) {
				ret new(Data)
			}

			let mut val = self.eval_expr_kind(pair.val)
			if !real(val) {
				ret new(Data)
			}

			self.s.check_assign_type(m.key, key, pair.colon, true)
			self.s.check_assign_type(m.val, val, pair.colon, true)

			model.entries = append(model.entries, &KeyValPairExprModel{
				key: key.model,
				val: val.model,
			})
		}

		ret &Data{
			mutable:    true,
			lvalue:     false,
			variadiced: false,
			decl:       false,
			kind:       &TypeKind{kind: m},
			model:      model,
		}
	}

	fn eval_brace_lit(mut &self, mut lit: &BraceLit): &Data {
		match {
		| !real(self.prefix):
			self.push_err(lit.token, "invalid_syntax")
			ret new(Data)

		| real(self.prefix.map()):
			ret self.eval_map(self.prefix.map(), lit)

		| real(self.prefix.strct()):
			ret self.eval_struct_lit_explicit(self.prefix.strct(), lit.exprs, lit.token)

		|:
			self.push_err(lit.token, "invalid_syntax")
			ret new(Data)
		}
	}

	fn eval_anon_fn(mut self, mut decl: &FnDecl): &Data {
		let mut tc = TypeChecker{
			s:      self.s,
			lookup: self.lookup,
		}
		let mut ins = tc.build_fn(decl)
		ins.anon = true

		match type self.lookup {
		| &ScopeChecker:
			let mut sc = (&ScopeChecker)(self.lookup)
			let mut scc = sc.new_child_checker()
			scc.labels = new([]&ScopeLabel, nil)
			scc.gotos = new([]&ScopeGoto, nil)
			drop(scc.owner)
			scc.child_index = 0
			scc.it = 0
			scc.cse = 0
			scc.owner = ins
			self.s.check_fn_ins_sc(ins, scc)

		|:
			self.s.check_fn_ins(ins)
		}

		ret &Data{
			kind: &TypeKind{kind: ins},
			model: &AnonFnExprModel{
				func:   ins,
				global: self.is_global(),
			},
		}
	}

	fn eval_binop(mut &self, mut op: &BinopExpr): &Data {
		let mut bs = BinopSolver{
			e: self,
		}
		ret bs.solve(op)
	}

	fn eval_expr_kind(mut &self, mut kind: ExprData): &Data {
		let mut d = new(Data)

		match type kind {
		| &LitExpr:         d = self.eval_lit((&LitExpr)(kind))
		| &IdentExpr:       d = self.eval_ident((&IdentExpr)(kind))
		| &UnaryExpr:       d = self.eval_unary((&UnaryExpr)(kind))
		| &VariadicExpr:    d = self.eval_variadic((&VariadicExpr)(kind))
		| &UnsafeExpr:      d = self.eval_unsafe((&UnsafeExpr)(kind))
		| &SliceExpr:       d = self.eval_slice_expr((&SliceExpr)(kind))
		| &IndexingExpr:    d = self.eval_indexing((&IndexingExpr)(kind))
		| &SlicingExpr:     d = self.eval_slicing((&SlicingExpr)(kind))
		| &CastExpr:        d = self.eval_cast((&CastExpr)(kind))
		| &NsSelectionExpr: d = self.eval_ns_selection((&NsSelectionExpr)(kind))
		| &StructLit:       d = self.eval_struct_lit((&StructLit)(kind))
		| &TypeDecl:        d = self.eval_type((&TypeDecl)(kind))
		| &FnCallExpr:      d = self.eval_fn_call((&FnCallExpr)(kind))
		| &SubIdentExpr:    d = self.eval_sub_ident((&SubIdentExpr)(kind))
		| &TupleExpr:       d = self.eval_tuple((&TupleExpr)(kind))
		| &BraceLit:        d = self.eval_brace_lit((&BraceLit)(kind))
		| &FnDecl:          d = self.eval_anon_fn((&FnDecl)(kind))
		| &BinopExpr:       d = self.eval_binop((&BinopExpr)(kind))
		|: drop(d)
		}

		if !real(d) {
			ret new(Data)
		}

		if !real(d.kind) {
			ret d
		}

		if !real(d.cast_kind) && d.is_const() && !d.is_rune && real(d.kind.prim()) {
			match {
			| d.constant.is_i64():
				if int_assignable((str)(PrimKind.Int), d) {
					d.kind.kind = build_prim_type((str)(PrimKind.Int))
				}

			| d.constant.is_u64():
				if int_assignable((str)(PrimKind.Uint), d) {
					d.kind.kind = build_prim_type((str)(PrimKind.Uint))
				}
			}
		}

		if !real(d.cast_kind) && !d.variadiced && !d.lvalue && !d.is_const() && real(d.kind.prim()) && is_num(d.kind.prim().kind) {
			d.cast_kind = d.kind
		}

		apply_cast_kind(d)
		ret d
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	fn eval(mut &self, mut expr: &Expr): &Data {
		let mut d = self.eval_expr_kind(expr.kind)
		if !real(d) || !real(d.kind) {
			ret new(Data)
		}

		match {
		| real(d.kind.fnc()):
			let mut f = d.kind.fnc()
			if f.is_builtin() {
				break
			}

			if f.generics.len != f.decl.generics.len {
				self.s.push_err(expr.token, "has_generics")
			}

			if f.decl.is_method() {
				self.s.push_err(expr.token, "method_not_invoked")
			}
		}

		ret d
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn eval_expr(mut &self, mut expr: &Expr): &Data {
		let mut d = self.eval(expr)
		match {
		| !real(d):
			ret new(Data)

		| d.decl:
			self.push_err(expr.token, "invalid_expr")
			ret new(Data)

		|:
			ret d
		}
	}
}

struct BinopSolver {
	e:  &Eval
	l:  &Data
	r:  &Data
	op: Token
}

impl BinopSolver {
	fn check_type_compatibility(mut self): bool {
		let mut tcc = TypeCompatibilityChecker{
			s:           self.e.s,
			error_token: self.op,
			dest:        self.l.kind,
			src:         self.r.kind,
			deref:       true,
		}
		ret tcc.check()
	}

	fn eval_nil(mut self): &Data {
		if !is_nil_compatible(self.r.kind) {
			self.e.push_err(self.op, "incompatible_types", (str)(TokenKind.Nil), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, (str)(TokenKind.Nil))
			ret new(Data)
		}
	}

	fn eval_enum(mut self): &Data {
		let mut enm = self.l.kind.enm()
		if !real(self.r.kind.enm()) || &enm != &self.r.kind.enm() {
			self.e.push_err(self.op, "incompatible_types", enm.ident, self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		| (str)(TokenKind.Amper)
		| (str)(TokenKind.Vline):
			if !real(enm.kind.kind.prim()) || !is_int(enm.kind.kind.prim().to_str()) {
				self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, enm.ident)
			}
			ret self.l

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, enm.ident)
			ret new(Data)
		}
	}

	fn eval_ptr(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq)
		| (str)(TokenKind.Lt)
		| (str)(TokenKind.Gt)
		| (str)(TokenKind.LessEq)
		| (str)(TokenKind.GreatEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_arr(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_slc(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_fn(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_struct(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_trait(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_any(mut self): &Data {
		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, (str)(PrimKind.Any))
			ret new(Data)
		}
	}

	fn eval_bool(mut self): &Data {
		if !self.check_type_compatibility() {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq)
		| (str)(TokenKind.DblAmper)
		| (str)(TokenKind.DblVline):
			ret self.l

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, self.l.kind.to_str())
			ret new(Data)
		}
	}

	fn eval_str(mut self): &Data {
		let mut rk = self.r.kind.to_str()
		if rk != (str)(PrimKind.Str) {
			self.e.push_err(self.op, "incompatible_types", self.l.kind.to_str(), rk)
			ret new(Data)
		}

		match self.op.kind {
		| (str)(TokenKind.Plus):
			ret self.l

		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}

		|:
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, (str)(PrimKind.Any))
			ret new(Data)
		}
	}

	fn set_type_to_greater(mut self) {
		if self.l.is_const() && self.r.is_const() || !self.l.is_const() && !self.r.is_const() {
			let lk = self.l.kind.to_str()
			let rk = self.r.kind.to_str()
			if is_greater(rk, lk) {
				self.l.kind = self.r.kind
			}
			ret
		}

		if self.l.is_const() {
			self.l.kind = self.r.kind
			ret
		}

		self.r.kind = self.l.kind
	}

	fn mod(mut self) {
		let check = fn(mut d: &Data) {
			if !d.is_const() {
				if !real(d.kind.prim()) || !is_int(d.kind.prim().kind) {
					self.e.push_err(self.op, "modulo_with_not_int")
				}
				ret
			}

			match {
			| sig_assignable((str)(PrimKind.I64), d):
				d.constant.set_i64(d.constant.as_i64())

			| unsig_assignable((str)(PrimKind.U64), d):
				d.constant.set_u64(d.constant.as_u64())

			|:
				self.e.push_err(self.op, "modulo_with_not_int")
			}
		}

		check(self.l)
		check(self.r)
	}

	fn eval_float(mut self): &Data {
		let lk = self.l.kind.to_str()
		let rk = self.r.kind.to_str()
		if !is_num(lk) || !is_num(rk) {
			self.e.push_err(self.op, "incompatible_types", lk, rk)
			ret new(Data)
		}

		// Logicals.
		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq)
		| (str)(TokenKind.Lt)
		| (str)(TokenKind.Gt)
		| (str)(TokenKind.GreatEq)
		| (str)(TokenKind.LessEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}
		}

		// Arithmetics.
		match self.op.kind {
		| (str)(TokenKind.Plus)
		| (str)(TokenKind.Minus)
		| (str)(TokenKind.Star)
		| (str)(TokenKind.Solidus):
			self.set_type_to_greater()
			ret self.l

		| (str)(TokenKind.Percent):
			if !is_int(rk) {
				self.e.push_err(self.op, "incompatible_types", lk, rk)
				ret new(Data)
			}
			self.mod()
			ret self.r

		|:
			self.e.push_err(self.op, "operator_not_for_float", self.op.kind)
			ret new(Data)
		}
	}

	fn eval_unsig_int(mut self): &Data {
		let lk = self.l.kind.to_str()
		let rk = self.r.kind.to_str()
		if !is_num(lk) || !is_num(rk) {
			self.e.push_err(self.op, "incompatible_types", lk, rk)
			ret new(Data)
		}

		// Logicals.
		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq)
		| (str)(TokenKind.Lt)
		| (str)(TokenKind.Gt)
		| (str)(TokenKind.GreatEq)
		| (str)(TokenKind.LessEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}
		}

		// Arithmetics.
		match self.op.kind {
		| (str)(TokenKind.Plus)
		| (str)(TokenKind.Minus)
		| (str)(TokenKind.Star)
		| (str)(TokenKind.Solidus)
		| (str)(TokenKind.Amper)
		| (str)(TokenKind.Vline)
		| (str)(TokenKind.Caret):
			self.set_type_to_greater()
			ret self.l

		| (str)(TokenKind.Percent):
			self.mod()
			self.set_type_to_greater()
			ret self.l

		| (str)(TokenKind.Lshift)
		| (str)(TokenKind.Rshift):
			if !is_ok_for_shifting(self.r) {
				self.e.push_err(self.op, "bitshift_must_unsigned")
				ret new(Data)
			}

			if self.l.is_const() {
				self.l.kind = self.r.kind
			}

			ret self.l

		|:
			self.e.push_err(self.op, "operator_not_for_uint", self.op.kind)
			ret new(Data)
		}
	}

	fn eval_sig_int(mut self): &Data {
		let lk = self.l.kind.to_str()
		let rk = self.r.kind.to_str()
		if !is_num(lk) || !is_num(rk) {
			self.e.push_err(self.op, "incompatible_types", lk, rk)
			ret new(Data)
		}

		// Logicals.
		match self.op.kind {
		| (str)(TokenKind.Eqs)
		| (str)(TokenKind.NotEq)
		| (str)(TokenKind.Lt)
		| (str)(TokenKind.Gt)
		| (str)(TokenKind.GreatEq)
		| (str)(TokenKind.LessEq):
			ret &Data{
				kind: &TypeKind{
					kind: build_prim_type((str)(PrimKind.Bool)),
				},
			}
		}

		// Arithmetics.
		match self.op.kind {
		| (str)(TokenKind.Plus)
		| (str)(TokenKind.Minus)
		| (str)(TokenKind.Star)
		| (str)(TokenKind.Solidus)
		| (str)(TokenKind.Amper)
		| (str)(TokenKind.Vline)
		| (str)(TokenKind.Caret):
			self.set_type_to_greater()
			ret self.l

		| (str)(TokenKind.Percent):
			self.mod()
			self.set_type_to_greater()
			ret self.l

		| (str)(TokenKind.Lshift)
		| (str)(TokenKind.Rshift):
			if !is_ok_for_shifting(self.r) {
				self.e.push_err(self.op, "bitshift_must_unsigned")
				ret new(Data)
			}

			ret self.l

		|:
			self.e.push_err(self.op, "operator_not_for_int", self.op.kind)
			ret new(Data)
		}
	}

	fn eval_prim(mut self): &Data {
		let prim = self.l.kind.prim()
		match {
		| prim.is_any():  ret self.eval_any()
		| prim.is_bool(): ret self.eval_bool()
		| prim.is_str():  ret self.eval_str()
		}

		let rprim = self.r.kind.prim()
		if !real(rprim) {
			self.e.push_err(self.op, "incompatible_types", prim.to_str(), self.r.kind.to_str())
			ret new(Data)
		}

		let lk = prim.to_str()
		match {
		| is_float(lk):     ret self.eval_float()
		| is_unsig_int(lk): ret self.eval_unsig_int()
		| is_sig_int(lk):   ret self.eval_sig_int()
		|:                  ret new(Data)
		}
	}

	fn eval(mut self): &Data {
		match {
		| self.l.kind.is_void():
			self.e.push_err(self.op, "operator_not_for_juletype", self.op.kind, "void")
			ret new(Data)

		| self.l.kind.is_nil():
			ret self.eval_nil()

		| real(self.l.kind.enm()):
			ret self.eval_enum()

		| real(self.l.kind.ptr()):
			ret self.eval_ptr()

		| real(self.l.kind.arr()):
			ret self.eval_arr()

		| real(self.l.kind.slc()):
			ret self.eval_slc()

		| real(self.l.kind.fnc()):
			ret self.eval_fn()

		| real(self.l.kind.trt()) || real(self.r.kind.trt()):
			if real(self.r.kind.trt()) {
				self.l, self.r = self.r, self.l
			}
			ret self.eval_trait()

		| real(self.l.kind.strct()):
			ret self.eval_struct()

		| real(self.l.kind.prim()):
			ret self.eval_prim()

		|:
			ret new(Data)
		}
	}

	fn assign_shift(self, mut d: &Data, r: f64) {
		match {
		| r <= 6:
			d.kind.prim().kind = (str)(PrimKind.I8)
			d.constant.set_i64(d.constant.as_i64())

		| r <= 7:
			d.kind.prim().kind = (str)(PrimKind.U8)
			d.constant.set_u64(d.constant.as_u64())

		| r <= 14:
			d.kind.prim().kind = (str)(PrimKind.I16)
			d.constant.set_i64(d.constant.as_i64())

		| r <= 15:
			d.kind.prim().kind = (str)(PrimKind.U16)
			d.constant.set_u64(d.constant.as_u64())

		| r <= 30:
			d.kind.prim().kind = (str)(PrimKind.I32)
			d.constant.set_i64(d.constant.as_i64())

		| r <= 31:
			d.kind.prim().kind = (str)(PrimKind.U32)
			d.constant.set_u64(d.constant.as_u64())

		| r <= 62:
			d.kind.prim().kind = (str)(PrimKind.I64)
			d.constant.set_i64(d.constant.as_i64())

		| r <= 63:
			d.kind.prim().kind = (str)(PrimKind.U64)
			d.constant.set_u64(d.constant.as_u64())

		| r <= 127:
			d.kind.prim().kind = (str)(PrimKind.F32)
			d.constant.set_f64(d.constant.as_f64())

		|:
			d.kind.prim().kind = (str)(PrimKind.F64)
			d.constant.set_f64(d.constant.as_f64())
		}
	}

	fn solve_const(mut self, mut d: &Data) {
		match {
		| !real(d):
			ret

		| !self.l.is_const()
		| !self.r.is_const():
			drop(d.constant)
			ret
		}

		match self.op.kind {
		| (str)(TokenKind.Eqs):
			d.constant = new_bool(self.l.constant.eqs(self.r.constant))


		| (str)(TokenKind.NotEq):
			d.constant = new_bool(!self.l.constant.eqs(self.r.constant))

		| (str)(TokenKind.DblColon):
			d.constant = new_bool(self.l.constant.or(self.r.constant))

		| (str)(TokenKind.DblAmper):
			d.constant = new_bool(self.l.constant.and(self.r.constant))

		| (str)(TokenKind.Gt):
			d.constant = new_bool(self.l.constant.gt(self.r.constant))

		| (str)(TokenKind.Lt):
			d.constant = new_bool(self.l.constant.lt(self.r.constant))

		| (str)(TokenKind.GreatEq):
			d.constant = new_bool(self.l.constant.gt(self.r.constant) || self.l.constant.eqs(self.r.constant))

		| (str)(TokenKind.LessEq):
			d.constant = new_bool(self.l.constant.lt(self.r.constant) || self.l.constant.eqs(self.r.constant))

		| (str)(TokenKind.Plus):
			_ = self.l.constant.add(self.r.constant)
			d.constant = self.l.constant

		| (str)(TokenKind.Minus):
			_ = self.l.constant.sub(self.r.constant)
			d.constant = self.l.constant

		| (str)(TokenKind.Star):
			_ = self.l.constant.mul(self.r.constant)
			d.constant = self.l.constant

		| (str)(TokenKind.Solidus):
			let ok = self.l.constant.div(self.r.constant)
			if !ok && self.r.constant.as_f64() == 0 {
				self.e.push_err(self.op, "divide_by_zero")
			}
			d.constant = self.l.constant

		| (str)(TokenKind.Percent):
			let ok = self.l.constant.mod(self.r.constant)
			if !ok && self.r.constant.as_f64() == 0 {
				self.e.push_err(self.op, "divide_by_zero")
			}
			d.constant = self.l.constant

		| (str)(TokenKind.Colon):
			_ = self.l.constant.bitwise_or(self.r.constant)
			d.constant = self.l.constant

		| (str)(TokenKind.Amper):
			_ = self.l.constant.bitwise_and(self.r.constant)
			d.constant = self.l.constant

		| (str)(TokenKind.Caret):
			_ = self.l.constant.xor(self.r.constant)
			d.constant = self.l.constant

		| (str)(TokenKind.Lshift):
			d.constant = self.l.constant
			_ = self.l.constant.lshift(self.r.constant)
			self.assign_shift(d, self.r.constant.as_f64())

		| (str)(TokenKind.Rshift):
			d.constant = self.l.constant
			_ = self.l.constant.rshift(self.r.constant)
			self.assign_shift(d, self.r.constant.as_f64())
		}

		d.model = d.constant
	}

	fn post_const(self, mut d: &Data) {
		if !real(d) {
			ret
		}
		if !d.is_const() {
			ret
		}

		normalize_bitsize(d)
	}

	fn prepare_data(self, mut d: &Data) {
		if real(d) && real(d.kind.ref()) {
			d.kind = d.kind.ref().elem
		}
	}

	fn prepare_eval(mut self) {
		self.prepare_data(self.r)
		self.prepare_data(self.l)
	}

	fn check_data(mut self, mut d: &Data) {
		let f = d.kind.fnc()
		if real(f) && real(f.decl) && f.decl.is_method() {
			self.e.push_err(self.op, "invalid_expr_for_binop")
		}
	}

	fn check_datas(mut self) {
		self.check_data(self.l)
		self.check_data(self.r)
	}

	fn solve_explicit(mut self, mut l: &Data, mut r: &Data): &Data {
		self.l, self.r = l, r

		self.prepare_eval()
		self.check_datas()

		let mut d = self.eval()
		self.l, self.r = l, r // Save normal order

		self.solve_const(d)
		self.post_const(d)

		if real(d) && !d.is_const() {
			d.model = &BinopExprModel{
				left:  l.model,
				right: r.model,
				op:    self.op.kind,
			}
		}

		if real(l.cast_kind) && !real(r.cast_kind) {
			d.cast_kind = l.cast_kind
		} else if real(r.cast_kind) && !real(l.cast_kind) {
			d.cast_kind = r.cast_kind
		}

		ret d
	}

	fn solve(mut self, mut op: &BinopExpr): &Data {
		let mut l = self.e.eval_expr_kind(op.left)
		if !real(l) || !real(l.kind) {
			ret new(Data)
		}

		let mut r = self.e.eval_expr_kind(op.right)
		if !real(r) || !real(r.kind) {
			ret new(Data)
		}

		self.op = op.op

		let mut d = self.solve_explicit(l, r)

		// Save rune type.
		if real(d) && l.is_rune && r.is_rune {
			d.is_rune = true
		}

		ret d
	}
}
